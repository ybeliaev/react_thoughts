<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/style.css" />
    <link rel="stylesheet" href="./src/highlight/styles/darcula.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&family=Roboto+Mono&family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <title>React thoughts</title>
  </head>

  <body>
    <div class="container">
      <h2>Варианты дефолтных значений</h2>
      <pre><code>
    function MyFunc({ text = &quot;some text&quot; }) {
      return &lt;div&gt;{text}&lt;/div&gt;;
    }
    const MySecondFunc = (props) =&gt; {
      return &lt;div&gt;{props.name || &quot;User&quot;}&lt;/div&gt;;
    };
    class MyClassComponent extends React.Component {
      render() {
        return &lt;div&gt;{this.props.name || &quot;User from class&quot;}&lt;/div&gt;;
      }
    }
    &lt;MyFunc text=&quot;1&quot; /&gt; // 1
    &lt;MyFunc /&gt; // some text
    &lt;MyFunc text=&quot;3&quot; /&gt; // 3
    &lt;MySecondFunc name=&quot;Yura&quot; /&gt; // Yura
    &lt;MySecondFunc /&gt; // User
    &lt;MyClassComponent name=&quot;John&quot; /&gt; // John
    &lt;MyClassComponent /&gt; // User from class
    </code></pre>
      <h2>Функция и класс</h2>
      <pre><code>
    const Welcome = ({ name }) =&gt; {
      return &lt;h2&gt;Hi, {name}!&lt;/h2&gt;;
    };
    class WelcomeClass extends React.Component {
      render() {
        return &lt;h2&gt;Hi, {this.props.name}!&lt;/h2&gt;;
      }
    }
    </code></pre>
      <h2>Дочерние компоненты</h2>
      <pre><code>
    const WelcomeAnn = () =&gt; {
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      return props.children;
    };
    //... 
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt;
    &lt;/Welcome&gt;
    </code></pre>
      <p>Для случая с разметкой было бы с фигурными скобками</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return &lt;h2&gt;{props.children}&lt;/h2&gt;;
    };
    </code></pre>
      <h2>Условные операторы</h2>
      <pre><code>
      // отрендорить children или default параметр
      const WelcomeAnn = () =&gt; {
        return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
      };
      
      const Welcome = (props) =&gt; {
        return &lt;h2&gt;{props.children ? props.children : &quot;default text&quot;}&lt;/h2&gt;;
      };
      // ... 
      &lt;Welcome&gt;
          &lt;WelcomeAnn /&gt; // Hello, Ann!
      &lt;/Welcome&gt;
      &lt;Welcome&gt;
                      // default text
      &lt;/Welcome&gt;
    </code></pre>
      <p>можно переписать с if</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h2&gt;{props.children}&lt;/h2&gt;;
      } else {
        return &lt;h2&gt;default text&lt;/h2&gt;;
      }
    };
    </code></pre>
      <p>Или так</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return props.children || &lt;h3&gt;default text&lt;/h3&gt;;
    };
    // props.children не обернул в h3 т.к он был бы внутри span
    </code></pre>
      <p>Даже сработает такое</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return (
        &lt;h3&gt;
          {props.children &amp;&amp; props.children}
          {!props.children &amp;&amp; &quot;default text&quot;}
        &lt;/h3&gt;
      );
    };
    // важно чтобы было что то возвращенно! иначе ошибка
    </code></pre>
      <h2>Спрятать отренденный компонент</h2>
      <pre><code>
    const WelcomeAnn = ({ hide }) =&gt; {
      if (hide) return null;
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h3&gt;{props.children}&lt;/h3&gt;;
      } else {
        return &lt;h3&gt;default text&lt;/h3&gt;;
      }
    };
    // .. 
    &lt;Welcome&gt;
      &lt;WelcomeAnn hide /&gt; // не отобразится
    &lt;/Welcome&gt;
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt; // Hello, Ann!
    &lt;/Welcome&gt;
    // если в первом компоненте передать hide={true}, 
    // а во втором hide={false} - ничего не изменится 
    </code></pre>
      <h2>Обработка событий</h2>
      <p>
        Чтобы свойства не очищались после вызова обработчика события исп. метод
        <code>event.persist()</code>
      </p>
      <pre><code>
    const handleClick = (e) =&gt; {
      <code>e.persist();</code>
      console.log(&quot;event&quot;, e); // в консоле свойства не будут null
    };
    
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <h3>Привязка this</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // undefined
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>1. bind</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
        <code>this.handleClick = this.handleClick.bind(this);</code>
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter 
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>2. синтаксис общедоступных полей классов</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (e) =&gt; {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Передача аргументов</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <p>запись функции подобна к</p>
      <pre><code>
    handleClick = function handleClick(data) {
      return function (e) {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
    };
    </code></pre>
      <p>ещё вариант передачи аргументов</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={(e) =&gt; this.handleClick(&quot;some text&quot;, e)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <p>И ещё</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick.bind(this, &quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    // замечу ,что с bind аргумент event явно не передавал
    </code></pre>
      <h2>Работа со списками</h2>
      <pre><code>
    const arr = [1, 2, 3, 4, 5, 6];
    const elements = arr.map((item) =&gt; &lt;li&gt;{item}&lt;/li&gt;);

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;ul&gt;<code>{elements}</code>&lt;/ul&gt; // elements в {}!
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }

    export default App;
    </code></pre>
      <p>В компонентах:</p>
      <pre><code>
      // List
    export const List = ({items}) =&gt; {
    const elements = items.map(item =&gt; &lt;li key={item.toString()}&gt;{item}&lt;/li&gt;)
        return &lt;ul&gt;{elements}&lt;/ul&gt;
    }
    // App 
    import { List } from &quot;./components/List&quot;;

    const arr = [1, 2, 3, 4, 5];

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;List items={arr} /&gt;
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }
    </code></pre>
      <h2>Изменение состояния</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        <code>
          this.setState({
            count: this.state.count + 1
          })
        </code>
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Сосотояние и жизненный цикл</h2>
      <h3>Асинхронное обновление</h3>
      <a href="https://habr.com/ru/post/358090/">Понимание жизненного цикла</a>
      <p>
        При наличии нескольких вызовов <code>setState()</code> React может
        объединять их в один общий пакет обновлений для увеличения
        производительности.
      </p>

      <p>
        Так как объекты <code>this.props</code> и <code>this.state</code> могут
        обновляться асинхронно, не стоит полагаться на значения этих объектов
        для вычисления состояния. Например:
      </p>
      <pre><code>
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
      </code></pre>
      <p>
        Для обновления надо использовать другую версию функции<code>
          setState()</code
        >, которая в качестве параметра принимает функцию. Данная функция имеет
        два параметра: предыдущее состояние объекта <code>state</code> и объект
        <code>props</code> на момент применения обновления:
      </p>
      <pre><code>
        this.setState(function(prevState, props) {
          return {
            counter: prevState.counter + props.increment
          };
        });
      </code></pre>
      <h2>Добавление методов жизненного цикла</h2>
      <p>
        первоначальный рендеринг компонента в DOM - mounting( монтирование )
      </p>
      <p>Размонтирование ( unmounting ) - узел удаляется</p>
      <p>
        <code>componentDidMount()</code> запускается после того, как компонен
        отренд. в DOM. Хорошее место для сетевых запросов, настройки подписок(не забыть отписаться)
      </p>
      <div class="alert">
        <p>
          Эта функция будет вызвана лишь раз во всем жизненном цикле данного
          компонента и будет сигнализировать, что компонент и все его дочерние
          компоненты отрисовались без ошибок.
        </p>
      </div>
      <div class="alert">
        <p>
          Т.к. эта функция гарантирована будет вызвана лишь раз, то это
          превосходный кандидат для выполнения любых сайд-эффектов, как то AJAX
          запросы.
        </p>
        <p>Не вызывайте this.setState т.к. это вызовет перерисовку.</p>
      </div>
      <div class="alert">
        <p>
          Побо́чные эффе́кты (англ. side effects) — любые действия работающей
          программы, изменяющие среду выполнения (англ. execution environment).
        </p>
        <p>
          Побочный эффект функции — возможность в процессе выполнения своих
          вычислений: читать и модифицировать значения глобальных переменных,
          осуществлять операции ввода-вывода, реагировать на исключительные
          ситуации, вызывать их обработчики. Если вызвать функцию с побочным
          эффектом дважды с одним и тем же набором значений входных аргументов,
          может случиться так, что в качестве результата будут возвращены разные
          значения.
        </p>
      </div>

      <p>Пример с часами</p>
      <pre><code>
      // ***** Clock ****
      import React from &quot;react&quot;;

      export class Clock extends React.Component{
          constructor(props) {
              super(props);
              this.state = {date: new Date()}
          }
          componentDidMount() {
              this.timerID = setInterval(() =&gt; this.tick(), 1000)
          }
          componentWillUnmount() {
              clearInterval(this.timerID)
          }
          tick(){
              this.setState({
                  date: new Date()
              })
          }

          render() {
              return(
                  &lt;div&gt;
                      &lt;h2&gt;Hi, clock!&lt;/h2&gt;
                      &lt;h3&gt;now {this.state.date.toLocaleTimeString()}&lt;/h3&gt;
                  &lt;/div&gt;
              )
          }
      }
      // **** App ****
      ... 
      &lt;Clock /&gt;
      ...
      // 1. вызов конструктора компонента, задаётся начальное состояние this.state
      // 2. вызов метода render() компонента Clock . Таким образом реакт узнаёт, что отобразить
      // 3. Обновление DOM в соответствии с render()
      // 4. Как только вставка в DOM произошла, Реакт вызывает метод жизненного цикла componentDidMount()
      // 5. Реакт реагирует на изменение состояния(запуск tick()) и снова запускает метод render()
      </code></pre>
      <p>Тикает!</p>
      <div class="alert">
        <p>Не копируйте пропсы в состояние:</p>
        <pre><code>
          this.setState({
            value: props.value
        })
        </code></pre>
        <p>Не менять состояние в конструкторе</p>
      </div>
      <p>
        <code>componentDidUpdate(prevProps, prevState)</code>: вызывается сразу
        после обновления компонента (если
        <code>shouldComponentUpdate</code> возвращает true). В качестве
        параметров передаются старые значения объектов <code>props</code> и
        <code>state</code>.
      </p>
      <div class="alert">
        <p>
          Эта функция будет вызываться после того как отработала функция render,
          в каждом цикле перерисовки. Это означает, что вы можете быть уверены,
          что компонент и все его дочерние компоненты уже перерисовали себя.
        </p>
        <p>
          В связи с этим эта функция является единственной функцией, что
          гарантировано будет вызвана только раз в каждом цикле перерисовки,
          поэтому любые сайд-эффекты рекомендуется выполнять именно здесь.
        </p>
      </div>
      <div class="alert">
        <p>Выполняйте сайд-эффекты (Вызовы AJAX и т.д.)</p>
        <p>
          Не вызывайте this.setState т.к. это будет вызывать циклическую
          перерисовку.
        </p>
      </div>
      <pre><code>
      // если userID не изменился - не нужно что то делать
      componentDidUpdate(prevProps, prevState, snapshot) {
        if(this.props.userID !== prevProps.userID)
            // что то делать
      }
      // можно и setState но только с условием if, иначе возможен бесконечный цикл
      </code></pre>
      <div class="alert">
        <p>
          <code>componentWillUnmount()</code>: вызывается перед удалением
          компонента из DOM - отмена таймера, подписок..созданных в
          componentWillMount(). Не использовать setState, т.к компонент никогда не рендорится повторно, т.к размонтирован
        </p>
      </div>
      <div class="alert">
        <p>
          Используйте эту функцию для «очистки» после компонента, если он
          использует таймеры (<code>setTimeout</code>,
          <code>setInterval</code>), открывает сокеты или производит любые
          операции, которые нуждаются в закрытии или удалении.
        </p>
      </div>
      <div class="alert">
        <p>
          Не вызывайте <code>this.setState</code>, не стартуйте новых слушателей
          или таймеры.
        </p>
      </div>
      <h2>Справка и примеры по хукам</h2>
      <h3>Зачем локальное состояние</h3>
      <pre><code>
      function App(){
        let nums = [1,2,3]
        const addNum = () =&gt; {
          nums.push(5)
        }
        return(
          &lt;div&gt;
            &lt;ul&gt;
              {nums.map(item =&gt; {
                &lt;li&gt;{item}&lt;/li&gt;
              })}
            &lt;/ul&gt;
            &lt;button onClick={addNum} &gt;New number&lt;/button&gt;
          &lt;/div&gt;
        )
      }
      // ПРИ НАЖАТИИ СПИСОК в DOM НЕ ОБНОВИТСЯ! React не отобразит изменения
      </code></pre>
      <pre><code>
      function App(){
        let [nums, setNums] = React.useState([1,2,3])
        const addNum = () =&gt; {
          let randNumber = Math.trunc(Math.rand() * 10)
          setNums([...nums, randNumber])          
        }
        return(
          &lt;div&gt;
            &lt;ul&gt;
              {nums.map(item =&gt; {
                &lt;li&gt;{item}&lt;/li&gt;
              })}
            &lt;/ul&gt;
            &lt;button onClick={addNum} &gt;New number&lt;/button&gt;
          &lt;/div&gt;
        )
      }
      // OK!
      </code></pre>
      <p>
        Т.е <code>useState</code> нужно , если изменяется переменая и соотв.
        должен происходить рирендер. В ином случае достаточно просто переменная.
      </p>
      <h3>UseEffect. Разбор.</h3>
      <p>Начну с повтора классовых компонентов.</p>
      <pre><code>
    componentDidMount // компонент был отображён/внедрён на странице и можно что-то сделать
    componentDidUpdate // в компоненте были изменения и сработает логика в теле метода(componentDidMount вызываться не будет)
    componentWillUnmount // компонент будет удалён и перед удалением сработает логика в теле метода
      </code></pre>
      <pre><code>
      // List 
      class List extends React.Component{
        state = {
          numbers: [1,2,3]
        }
        addNumbers = () =&gt; {
          let randNumber = Math.trunc(Math.random() * 10)            
          this.setState({
            numbers: [...this.state.numbers, randNumber]
          })
        }
        componentDidMount(){
          // 1 раз при монтировании/рендере компонента. При изменениях не вызывается
          console.log("Компонент был отображён!") 
        }
        сomponentDidUpdate(prevProps, prevState){ // prevProps - старый props prevState - старый state
          console.log("Изменился state или props!") 
          // при первом  рендере НЕ сработает. Сработает при нажатии на button
          // при нажатии, напр., получу число 10
          // prevProps: {} prevState: numbers: [1,2,3]
          // this.props ( props после изменения ): {} - нет изменений
          // this.state: numbers: [1,2,3,10]
          if(this.state.numbers.length !== prevState.numbers.length){
            // сработает при каждом добавлении числа
            console.log("Обновился список чисел!") 
          }
        }

        render(){
          return(
            &lt;div&gt;
              &lt;ul&gt;
                {this.state.numbers.map(i =&gt; {
                  &lt;li&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={this.addNumbers}&gt;Click&lt;/button&gt;
            &lt;/div&gt;
          )
        }
      }
      // App 
      let [visibleList, setVisibleList] = React.useState(true)
      function App(){
        let toggleList = () => {
          // setVisibleList может получать как само значение так и функцию
          setVisibleList((visible) => !visible)// чтобы не передалось старое состояние, исп. анонимную функцию
        }
        return(
        &lt;div className = &quot;App&quot;&gt;
          {visibleList && &lt;List/&gt;} // если visibleList == true , то компонент отобразится 
          &lt;button onClick={toggleList}&gt;Click&lt;/button&gt;
        &lt;/div&gt;
        )
      }
      // при отображении компонента после его удаления будет вызываться componentDidMount()
      </code></pre>
      <p>теперь как понять, что компонент был удалён - использовать <code>componentWillUnmount</code></p>
      <pre><code>
        // List 
      class List extends React.Component{
        state = {
          numbers: [1,2,3]
        }
        addNumbers = () =&gt; {
          let randNumber = Math.trunc(Math.random() * 10)            
          this.setState({
            numbers: [...this.state.numbers, randNumber]
          })
        }
        componentDidMount(){          
          console.log("Компонент был отображён!") 
        }
        сomponentDidUpdate(prevProps, prevState){                       
          if(this.state.numbers.length !== prevState.numbers.length){            
            console.log("Обновился список чисел!") 
          }
        }
        componentWillUnmount(){
          // надпись выведется при (перед) удалении компонента List
          console.log("Компонент будет удалён!")
        }

        render(){
          return(
            &lt;div&gt;
              &lt;ul&gt;
                {this.state.numbers.map(i =&gt; {
                  &lt;li&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={this.addNumbers}&gt;Click&lt;/button&gt;
            &lt;/div&gt;
          )
        }
      }
      // App 
      let [visibleList, setVisibleList] = React.useState(true)
      function App(){
        let toggleList = () => {          
          setVisibleList((visible) => !visible)
        }
        return(
        &lt;div className = &quot;App&quot;&gt;
          {visibleList && &lt;List/&gt;} 
          &lt;button onClick={toggleList}&gt;Click&lt;/button&gt;
        &lt;/div&gt;
        )
      }
      </code></pre>
      <h3>Тоже самое на хуках</h3>
      <pre><code>
        //*** List***

        const List = () =&gt; {
          let [numbers, setNumbers] = React.useState([1,2,3])

          let addNumber = () =&gt; {
            let randNumber = Math.round(Math.random() * 10)
            let newArr = [...numbers, randNumber]
            setNumbers(newArr)
          }
        }

        React.useEffect(() =&gt; {
          console.log(&quot;Компонент был отображён!&quot;) 
        }, [])
        // если  useEffect() получает вторым элементом пустой масив -  componentDidMount()
        // т.е отловлено просто первое отображение компонента        
        // если ничего не передать , то useEffect() будет при и при первом рендере и при обновлениях
        return(
          &lt;div&gt;
            &lt;ul&gt;
              {numbers.map(i =&gt; {
                &lt;li&gt;{i}&lt;/li&gt;
              })}
            &lt;/ul&gt;
            &lt;button onClick={addNumbers}&gt;Click&lt;/button&gt;
          &lt;/div&gt;
        ) 

        // ***App*** 
      let [visibleList, setVisibleList] = React.useState(true)
      function App(){
        let toggleList = () => {          
          setVisibleList((visible) => !visible)
        }
        return(
        &lt;div className = &quot;App&quot;&gt;
          {visibleList && &lt;List/&gt;} 
          &lt;button onClick={toggleList}&gt;Click&lt;/button&gt;
        &lt;/div&gt;
        )
      }          
      // 
      </code></pre>
      <pre><code>
        //*** List***

        const List = () =&gt; {
          let [numbers, setNumbers] = React.useState([1,2,3])
          let [count, setCount] = React.useState(0)


          let addNumber = () =&gt; {
            let randNumber = Math.round(Math.random() * 10)
            let newArr = [...numbers, randNumber]
            setNumbers(newArr)
          }
        }

        React.useEffect(() =&gt; {
          console.log("Список чисел был обновлён") 
        }, [numders])        
        
        return(
          &lt;div&gt;
          &lt;button onClick={() => setCount(count+1)}&gt;Click count&lt;/button&gt;
          &lt;h2&gt;{count}&lt;/div&gt;          
            &lt;ul&gt;
              {numbers.map(i =&gt; {
                &lt;li&gt;{i}&lt;/li&gt;
              })}
            &lt;/ul&gt;
            &lt;button onClick={addNumbers}&gt;Add number&lt;/button&gt;
          &lt;/div&gt;
        ) 
        // жму Add number - вызывается "Список чисел был обновлён"
        // жму Click count - ничего
      </code></pre>
      <pre><code>
        React.useEffect(() => {
          console.log("Список чисел был обновлён") 
        }, [numders, count]) 
        // теперь и при нажатии на Click count консоль сработает
        // если убрать [] то useEffect будет следить за изменением любого стейта или пропса этого компонента
      </code></pre>
      <h3>теперь как понять что компонент будет удалён</h3>
      <pre><code>
        // для этого React.useEffect должно возвращать новую анонимную функцию
        React.useEffect(() => {
          console.log("Component did Mount!") 
          return () => {
            console.log("Component will UnMount!") 
          }
        }, [])
        // "Component will UnMount!" будет при нажатии на кнопку, скрывающую компонент
        // но при нажатии на ту же кнопку с результатом отображения - "Component will UnMount!" нет
        
      </code></pre>
      <h2>useRef</h2>
      <pre><code>
        // ***App*** 
        function App(){
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let addNumber = () =&gt; {
            let lastNumber = numbers[numbers.length - 1]
            setNumbers([...numbers, lastNumber])
          }
          return(
            &lt;div&gt;
              &lt;ul&gt;
                {numbers.map((i, idx) =&gt; {
                  &lt;li key={idx}&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={addNumber}&gt;Add number&lt;/button&gt;
            &lt;/div&gt;
          )
        }
      </code></pre>
      <p>Задача выдать что-то в консоль при скролле</p>
      <pre><code>
        // ***App*** 
        function App(){
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let addNumber = () =&gt; {
            let lastNumber = numbers[numbers.length - 1]
            setNumbers([...numbers, lastNumber])
          }

          let handleScroll = () => {
            console.log("Был скролл")
          }

          let ulElem = document.querySelector("ul")
          ulElem.addEventListener("scroll", handleScroll)
          // будет ошибка: ulElem == null, поэтому null.addEventListener это TypeError
          // это потому, что код ДО рендера разметки(которая в return)
          return(
            &lt;div&gt;
              &lt;ul&gt;
                {numbers.map((i, idx) =&gt; {
                  &lt;li key={idx}&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={addNumber}&gt;Add number&lt;/button&gt;
            &lt;/div&gt;
          )
        }
      </code></pre>
      <p>Попытка два: использую useEffect</p>
      <pre><code>
        React.useEffect(() => {
          let ulElem = document.querySelector("ul")
          ulElem.addEventListener("scroll", handleScroll)
        }, [])
        // т.е говорю: при первом рендере выполни этот код
        // скролл работает
      </code></pre>
      <p>Что если хочу удалять скролл</p>
      <pre><code>
        // ***App*** 
        function App(){
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let addNumber = () =&gt; {
            let lastNumber = numbers[numbers.length - 1]
            setNumbers([...numbers, lastNumber])
          }

          let handleScroll = () => {
            console.log("Был скролл")
          }

          React.useEffect(() => {
            let ulElem = document.querySelector("ul")
            ulElem.addEventListener("scroll", handleScroll)
          }, [])

          let removeScroll = () => {
            ulElem.removeEventListener("scroll", handleScroll)
          }
          // разумеется, так не сработает ulElem is not defined, т.к она инициал. в другой функции

          return(
            &lt;div&gt;
              &lt;ul&gt;
                {numbers.map((i, idx) =&gt; {
                  &lt;li key={idx}&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={addNumber}&gt;Add number&lt;/button&gt;
              &lt;button onClick={removeScroll}&gt;Remove scroll&lt;/button&gt;
            &lt;/div&gt;
          )
        }
      </code></pre>
      <p>Одно из решений(тупое, конечно) - вынести <code>ulElem</code> в родит. функцию, чтобы её видели все по замыканию</p>
      <pre><code>
        // ***App*** 
        function App{
          let ulElem;
          ..
        }
      </code></pre>
      <p>Но после добавлении нового числа к массиву <code>ulElem</code> будет не <code>ul</code>, а <code>underfined</code></p>
      <p>Причина в том ,что при обновлении компонента(<code>App</code> в данном случае) - это обновление пропсов или стейт будет перерендеринг ,т.е новый вызов <code>App</code> - переменные будут пересоздаваться</p>
      <pre><code>
        // ***App*** 
        function App(){
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let ulRef = React.useRef();
          console.log(ulRef) // { current: undefined } не пересоздаётся при обновлении компонента
          // при &lt;ul ref={ulRef}&gt; { current: ul }
          
          return(
            &lt;div&gt;
              &lt;ul ref={ulRef}&gt;
                {numbers.map((i, idx) =&gt; {
                  &lt;li key={idx}&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={addNumber}&gt;Add number&lt;/button&gt;
              &lt;button onClick={removeScroll}&gt;Remove scroll&lt;/button&gt;
            &lt;/div&gt;
          )          
        }
        </code></pre>
        <p>теперь код будет выглядеть</p>
        <pre><code>
          // ***App*** 
        function App(){
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let ulRef = React.useRef();
          
          let addNumber = () =&gt; {
            let lastNumber = numbers[numbers.length - 1]
            setNumbers([...numbers, lastNumber])
          }

          let handleScroll = () => {
            console.log("Был скролл")
          }

          React.useEffect(() => {            
            ulRef.current.addEventListener("scroll", handleScroll)
          }, [])

          let removeScroll = () => {
            ulRef.current.removeEventListener("scroll", handleScroll)
          }
          return(
            &lt;div&gt;
              &lt;ul ref={ulRef}&gt;
                {numbers.map((i, idx) =&gt; {
                  &lt;li key={idx}&gt;{i}&lt;/li&gt;
                })}
              &lt;/ul&gt;
              &lt;button onClick={addNumber}&gt;Add number&lt;/button&gt;
              &lt;button onClick={removeScroll}&gt;Remove scroll&lt;/button&gt;
            &lt;/div&gt;
          )          
        } 
        </code></pre>
        <p>Ещё применение useRef</p>
        <pre><code>
        function App(){
          let timer;
          let[numbers, setNumbers] = React.useState([1,2,3,4,5])
          let ulRef = React.useRef();
          
          let addNumber = () =&gt; {
            let lastNumber = numbers[numbers.length - 1]
            setNumbers([...numbers, lastNumber])
          }
          let start = () => {
            timer = setInterval(addNumber, 1000) //каждый раз при вызове функции, numbers будет иметь старое значение
          }
          let stop = () => {
            clearInterval(timer)
          }
          .. там кнопки "старт" "стоп" "добавить число"
        }
        </code></pre>
        <p>как исправить</p>
        <pre><code>
        let addNumber = () =&gt; {          
          setNumbers(prev =>[... prev, prev[prev.length - 1] + 1])
        }
        // но кнопка стоп не работает ,т.к timer пересоздаётся
        </code></pre>
        <pre><code>
          function App(){
            
            let[numbers, setNumbers] = React.useState([1,2,3,4,5])
            let timerRef = React.useRef();
            
            let addNumber = () => {          
              setNumbers(prev =>[... prev, prev[prev.length - 1] + 1])
            }
            let start = () => {
              timerRef.current = setInterval(addNumber, 1000) 
            }
            let stop = () => {
              clearInterval(timerRef.current)
            }
            ..            
          }
        </code></pre>
        <h2>Состояние и жизненный цикл</h2>
        <div class="alert">
          <p>Функция - компонент, когда она получает данные в одном объекте(пропсы) в качестве параметра и возвращает React-элемент</p>
        </div>
        <div class="alert">
          <p> React-элемент содержит DOM-теги и\или собственные компоненты:</p>
        </div>
        <pre><code>
          let element1 = &lt;div /&gt;
          let element2 = &lt;Wellcome name="Elly" /&gt;
        </code></pre>
        <div class="alert">
          <p>React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам</p>
        </div>
        <ul>
          <li>
            <span>Состояние нельзя менять напрямую. Только в конструкторе(если классовый компонент)</span>
            <pre><code>
              this.state.count = this.state.count + 1
            </code></pre>
            <pre><code>
              this.setState({count: this.state.count + 1})
            </code></pre>
          </li>

          <li>
            <span>this.props и this.state могут обновляться ассинхронно</span>
            <pre><code>
              // this.props.incriment получаю ассинхронно
              // так неправильно:
              this.setState({count: this.state.count + this.props.incriment})
            </code></pre>
            <pre><code>
              // функция получит предидущее состояние как первый аргумент
              // значение пропсов непосредственно во время обновления как второй аргумент 
              this.setState( (state, props) => ({ count: state.count + props.incriment }) )
              // или обычная функция
              this.setState( function(state, props) { return  { count: state.count + props.incriment }} )
            </code></pre>
          </li>
          <li>
            Состояния могут объединяться
            <pre><code>
              export class ClickCounter extends React.Component{
                constructor(props){
                  super(props);
                  this.state = {
                    count: 0,
                    fetchData1: {
                      value: "value",
                      data: ["some text", "text"]
                    },
                    fetchData2: [1,2,3]
                  }
                }
                handleClick = (data) => (e) => {
                  this.setState( (state, props) => ({ fetchData2: [4,5,6] }) )
                  // newFetchData - какой-то объект, пришедший из пропс                  
                  this.setState( (state, props) => ({ fetchData1: props.newFetchData }) ) 
                  // если нужно только одно свойство обновить:
                  this.setState( (state, props) => ({ fetchData1: {
                    value: this.props.newFetchData.value,
                    data: [1,2,3]
                  } }) ) 
                }
              }
            </code></pre>
          </li>
        </ul>
        <div class="alert">
          <p>Единственный обязательный метод в классовом компоненте - render(). При вызове он проверяет <code>this.props</code> и <code>this.state</code></p>
        </div>
        <div class="alert">
          <p>Не копируйте пропсы в состояние:</p>
          <pre><code>
            constructor(props){
              super(props);
              this.state = {
                someValue: props.someValue
              }
            }
          </code></pre>
        </div>
        <h2>Работа с формами</h2>
        <h3>Управляемый компонент</h3>
        <pre><code>
          class NameForm extends React.Component {
            constructor(props) {
              super(props);
              this.state = {value: ""};
          
              this.handleChange = this.handleChange.bind(this);
              this.handleSubmit = this.handleSubmit.bind(this);
            }
          
            handleChange(event) {
              this.setState({value: event.target.value});
            }
          
            handleSubmit(event) {
              alert(&#039;Отправленное имя: &#039; + this.state.value);
              event.preventDefault();
            }
          
            render() {
              return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                  &lt;label&gt;
                    Имя:
                    &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;
                    // если убрать value={this.state.value} onChange={this.handleChange}
                    // то написать что-ито в поле input будет невозможно, т.к this.state = {value: ""};
                  &lt;/label&gt;
                  &lt;input type=&quot;submit&quot; value=&quot;Отправить&quot; /&gt;
                &lt;/form&gt;
              );
            }
          }
        </code></pre>
        <h3>Неуправляемый компонент</h3>
        <pre><code>
          class NameForm extends React.Component {
            constructor(props) {
              super(props);              
              this.handleSubmit = this.handleSubmit.bind(this);
              this.input = React.createRef();
            }          
            
            handleSubmit(event) {
              event.preventDefault();
              alert(&#039;Отправленное имя: &#039; + this.input.current.value);
            }
          
            render() {
              return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                  &lt;label&gt;
                    Имя:
                    &lt;input type=&quot;text&quot; ref = {this.input} /&gt;
                  &lt;/label&gt;
                  &lt;input type=&quot;submit&quot; value=&quot;Отправить&quot; /&gt;
                &lt;/form&gt;
              );
            }
          }
        </code></pre>
        <h2>Запись через точку</h2>
        <h3>Это удобно, если есть модуль, экспортирующий много React-элементов</h3>
        <pre><code>
          import React from "react"

          const MyComponent = {
            DatePicker: function DatePicker(props){
              return &lt;div&gt; some color {props.color} &lt;/div&gt;
            }
          }
          function BlueDatePicker(){
            return &lt;MyComponent.DatePicker color="blue"/&gt;
          }
        </code></pre>

        <h2>Применение clsx</h2>
        <pre><code>
          // App()
        import { Button } from "./components/Button/Button";
        import { Icon } from "./components/Icon/Icon";

        function App() {
          return (
            &lt;div className=&quot;App&quot;&gt;
              &lt;header className=&quot;App-header&quot;&gt;
                &lt;Icon iconType=&quot;plus&quot;/&gt;
                &lt;Icon iconType=&quot;cross&quot; color=&#039;red&#039;/&gt;
                &lt;Button 
                size=&quot;large&quot;
                color=&quot;secondary&quot;
                iconType=&quot;cross&quot;
                className=&quot;some&quot;
                &gt;Click&lt;/Button&gt;
              &lt;/header&gt;
            &lt;/div&gt;
          );
        }


          // Button.jsx
          import clsx from "clsx"
          import styles from "./Button.module.scss"

          export const Button = (props) => {

            const { children,className, size, color, type = "button", ...rest } = props;
            return (
              &lt;button 
              type={type}
              className={clsx([
                  styles.btn,
                  {
                    [styles[size]]: size, // если будет какое то значение, то отрендерится className с таким же названием(small или large)
                    [styles[`btn_${color}`]]: color
                  },
                  className
              ])}
              &gt;
                 {children}
              &lt;/button&gt;
            )
        }

        // Button.module.scss 
        .btn {
          position: relative;
          display: inline-block;
          background: transparent;
          border: 1px solid  #03e9f4;
          padding: 10px 20px;
          color: #03e9f4;
          font-size: 16px;
          text-decoration: none;
          text-transform: uppercase;
          transition: .5s;
          letter-spacing: 4px;
          cursor: pointer;
          outline: 0;
        
          &:hover, &:focus {
            background: #03e9f4;
            color: #fff;
            border-radius: 5px;
            box-shadow: 0 0 5px #03e9f4,
            0 0 25px #03e9f4,
            0 0 50px #03e9f4,
            0 0 100px #03e9f4;
        
          }
          &_primary{
              color: #39c4d5;
              border-color: #39c4d5;
              box-shadow: 0 0 5px #39c4d5,
              0 0 25px #39c4d5,
              0 0 50px #39c4d5,
              0 0 100px #39c4d5;
            }
          
            &_secondary{
              color: #607d8b;
              border-color: #607d8b;
              box-shadow: 0 0 5px #607d8b,
              0 0 25px #607d8b,
              0 0 50px #607d8b,
              0 0 100px #607d8b;
            }
        
        }
        .large{
          padding: 15px 25px;
          font-size: 20px;
              .icon{
                  margin-right: 15px;
              }
              .resetMarginRight {
                  margin-right: 0;
              }
          }
            
          .small{
          padding: 7px 10px;
          font-size: 14px;
              .icon{
                  margin-right: 5px;
              }
              .resetMarginRight {
                  margin-right: 0;
              }
          }
        </code></pre>

        <h2>События в React</h2>
        <div class="alert">
          <p>В <code>React</code> обработчик события вешается на <code>document</code>, так легче решать вопросы с утечкой памяти(когда нужно удалить обработчик)</p>
          <p>В будующем планируют обработчик вешать на <code>#root</code></p>
        </div>
        <pre><code>
          function Button({children, kind="primery", size="md", disabled=false}){
            return &lt;button className = {`btn btn-${kind}`} btn-${size} disabled={disabled}&gt;
              {children}
            &lt;/button&gt;
          }

          let ui = &lt;div&gt;
            &lt;Button onClick = {event =&gt; console.log(&quot;!&quot;)}&gt;&lt;/Button&gt;
          &lt;/div&gt;
          ReactDOM.render(ui, document.getElementtById(&quot;root&quot;))
        </code></pre>
        <p>Не работает обработка события. Почему?</p>
        <div class="alert">
          <p>Компонента не привязывает обработчик сама к дом узлу. У узла <code>button</code> нет <code>onClick</code></p>
        </div>
        <p>Нужно:</p>
        <pre><code>
          function Button({children, kind="primery", onClick, size="md", disabled=false}){
            return &lt;button 
                className = {`btn btn-${kind}`} 
                btn-${size} 
                disabled={disabled}
                <code>onClick={onClick}</code>
                &gt;
              {children}
            &lt;/button&gt;
          }

          let ui = &lt;div&gt;
            &lt;Button onClick = {event =&gt; console.log(&quot;!&quot;)}&gt;&lt;/Button&gt;
          &lt;/div&gt;
          ReactDOM.render(ui, document.getElementtById(&quot;root&quot;))
        </code></pre>
        <h3>Всплывание событий</h3>
        <p>Что будет в консоли при двух обработчиках:</p>
        <pre><code>
          function Button({children, kind="primery", onClick, size="md", disabled=false}){
            return &lt;button 
                className = {`btn btn-${kind}`} 
                btn-${size} 
                disabled={disabled}
                onClick={onClick}
                &gt;
              {children}
            &lt;/button&gt;
          }

          let ui = &lt;div onClick = {event =&gt; console.log(&quot;ui click bubling!&quot;)}
                        onClickCapture = {event =&gt; console.log(&quot;ui click capturing!&quot;)}
            &gt;
            &lt;Button onClick = {event =&gt; console.log(&quot;button click!&quot;)}&gt;&lt;/Button&gt;
          &lt;/div&gt;
          ReactDOM.render(ui, document.getElementtById(&quot;root&quot;))
        </code></pre>
        <p>Будет: <br> <code>ui click capturing!</code><br><code>ui click!</code><br><code>ui click bubling!</code></p> 

        <h3>onChange, onKeyPress</h3>
        <pre><code>
          let ui = &lt;div onkeyPress={event => console.log(event.key)} &gt;
            &lt;input onChange={(e)=>console.log(e.target.value)}/&gt;
          &lt;/div&gt;
          // когда фокус в input = ловит onkeyPress
        </code></pre>

        <div class="alert">
          <p>Свойство <code>target</code> ссылается на дом узел, где было зарегестирировано событие</p>
        </div>
        <h3>Форма. Основы.</h3>
        <h4>Перехватывать нажатие на кнопку и получение значений полей</h4>
        <pre><code>
          function Form({children}){
            return &lt;form onSubmit={(e)=>{

            }}&gt;
            {children}
              
            &lt;/form&gt;
          }
          let ui = &lt;Form&gt;
            &lt;div&gt;
              &lt;input autoComplite=&quot;off&quot; name=&quot;username&quot;&gt; UserName
            &lt;/div&gt;
            &lt;div&gt;
              &lt;input autoComplite=&quot;off&quot; name=&quot;email&quot;&gt; Email
            &lt;/div&gt;
            &lt;div&gt;
              &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
            &lt;/div&gt;
          &lt;/Form&gt;
        </code></pre>
        <p>Сейчас работает дефолтное устаревшее поведение: при нажатии на кнопку браузер делает get запрос и перегружается</p>
        <p>Решения:</p>
        <pre><code>
          &lt;div&gt;
              &lt;button type=&quot;button&quot;&gt;Login&lt;/button&gt;
            &lt;/div&gt;
        </code></pre>
        <p>Но теперь нажатие на кнопку не отправляет форму, и мы не можем встроиться в обработчик <code>onSubmit</code></p>
        <p>Правильно:</p>
        <pre><code>
          function Form({children}){
            return &lt;form onSubmit={(e)=>{
              <code>e.preventDefault()</code>
            }}&gt;
            {children}
              
            &lt;/form&gt;
          }
        </code></pre>
        <p>Получаю доступ к элементу формы:</p>
        <pre><code>
          function Form({children}){
            return &lt;form onSubmit={(e)=>{
              e.preventDefault()
              console.log(e.target)// = &lt;form&gt; div div div &lt;/form&gt;
            }}&gt;
            {children}
              
            &lt;/form&gt;
          }
        </code></pre>
        <pre><code>
          function Form({children}){
            return &lt;form onSubmit={(e)=>{
              e.preventDefault()
              console.log(e.target.elements.username)// = получаю данный input за счёт атрибута name в нём. Это не значение поля, а ссылка на дом узел
              console.log(e.target.elements.email) 
              console.log(e.target.email)// shortcut короткая запись              
            }}&gt;
            {children}
              
            &lt;/form&gt;
          }
        </code></pre>
        <p>Получаю значения узлов формы:</p>
        <pre><code>
          function Form({children}){
            return &lt;form onSubmit={(e)=>{
              e.preventDefault()
              let form = e.target;
              let {username, email} = form;
              console.log(username.value) // это и будет значение поля
              console.log(email.value) // это и будет значение поля
              {children}              
            &lt;/form&gt;
          }
        </code></pre>
        <h2>Hook useState</h2>
        <p>Состояние - то, что меняется со временем, от чего зависит более одного виджета.</p>
        <div class="alert">
          <p>useState - функция, возвращающая массив</p>
        </div>
        <div class="alert">
          <p>Изменение состояния вызывает перерендер.</p>
        </div>
        <div class="alert">
          <p>Хуки не могут быть в циклах\условиях и должны быть вверху функции.</p>
        </div>
        <h3>Найди ошибку</h3>
        <pre><code>          
          function App(){
            let [counter, setCounter] = useState(0)
            
            return &lt;div&gt;
            {counter}
            &lt;Button onClick={onClick} kind="primery" &gt;+&lt;/Button&gt;
            
            &lt;/div&gt;
          }

          function Button({children, kind, onClick}){
            return &lt;button 
                    onClick={setCounter(counter + 1)} 
                    className={`btn btn-${kind}`} 
                    &gt;
                     {children}
                    &lt;/button&gt;
          }
        </code></pre>
        <p><code>onClick={setCounter(counter + 1)}</code> <code>setCounter</code> вызывается в момент рендера, он меняет <code>state</code> и поэтому снова вызывается = вечный цикл </p>
        <h2>Ключи</h2>
        <p>Почему код не меняет местами <code>input</code> а только текст?</p>
        <pre><code>
          let initialItems = ["Learn Reract", "Learn TypeScript"]

          function App(){
            let [items, setItems] = useState(initialItems)

            function handleClick(){
              setItems(...[items].reverse())
            }

            return &lt;div&gt;
              &lt;ul&gt;
                {items.map((item)=>
                  &lt;li&gt;
                    &lt;label&gt;
                      &lt;input type=&quot;checkbox&quot;/&gt;
                     {item}                  
                    &lt;/label&gt;
                  &lt;/li&gt;
                )}
                &lt;button onClick=(handleClick) &gt;Reverse&lt;/button&gt;                
              &lt;/ul&gt;              
            &lt;/div&gt;
          }
        </code></pre>
        <p>При сравнении двух состояний чекбоксы остаются неизменными, а меняется текст. Поэтому Реакт меняет только его.</p>
        <h3>Как сделать чтобы чекбокс перемещался со строкой?</h3>
        <pre><code>
          ... 
          return &lt;div&gt;
              &lt;ul&gt;
                {items.map((item, idx)=>
                  &lt;li <code>key={item}</code>&gt;
                    &lt;label&gt;
                      &lt;input type=&quot;checkbox&quot;/&gt;
                     {item}                  
                    &lt;/label&gt;
                  &lt;/li&gt;
                )}
                &lt;button onClick=(handleClick) &gt;Reverse&lt;/button&gt;                
              &lt;/ul&gt;              
            &lt;/div&gt;
        </code></pre>
        <p>Если &lt;li <code>key={idx}</code>&gt; - этот идентификатор не идентифицирует строку списка уникальной</p>
        <p>Т.е передан offset - смещение. Поведение станет старым. Для списков, которые точно не меняют свою длинну, положение элементов такой идентификатор возможен.</p>

        
      <!-- container  -->
    </div>
    <script src="./src/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>