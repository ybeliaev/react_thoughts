<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/style.css" />
    <link rel="stylesheet" href="./src/highlight/styles/darcula.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&family=Roboto+Mono&family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <title>React thoughts</title>
  </head>

  <body>
    <div class="container">
      <h2>Варианты дефолтных значений</h2>
      <pre><code>
    function MyFunc({ text = &quot;some text&quot; }) {
      return &lt;div&gt;{text}&lt;/div&gt;;
    }
    const MySecondFunc = (props) =&gt; {
      return &lt;div&gt;{props.name || &quot;User&quot;}&lt;/div&gt;;
    };
    class MyClassComponent extends React.Component {
      render() {
        return &lt;div&gt;{this.props.name || &quot;User from class&quot;}&lt;/div&gt;;
      }
    }
    &lt;MyFunc text=&quot;1&quot; /&gt; // 1
    &lt;MyFunc /&gt; // some text
    &lt;MyFunc text=&quot;3&quot; /&gt; // 3
    &lt;MySecondFunc name=&quot;Yura&quot; /&gt; // Yura
    &lt;MySecondFunc /&gt; // User
    &lt;MyClassComponent name=&quot;John&quot; /&gt; // John
    &lt;MyClassComponent /&gt; // User from class
    </code></pre>
      <h2>Функция и класс</h2>
      <pre><code>
    const Welcome = ({ name }) =&gt; {
      return &lt;h2&gt;Hi, {name}!&lt;/h2&gt;;
    };
    class WelcomeClass extends React.Component {
      render() {
        return &lt;h2&gt;Hi, {this.props.name}!&lt;/h2&gt;;
      }
    }
    </code></pre>
      <h2>Дочерние компоненты</h2>
      <pre><code>
    const WelcomeAnn = () =&gt; {
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      return props.children;
    };
    //... 
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt;
    &lt;/Welcome&gt;
    </code></pre>
      <p>Для случая с разметкой было бы с фигурными скобками</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return &lt;h2&gt;{props.children}&lt;/h2&gt;;
    };
    </code></pre>
      <h2>Условные операторы</h2>
      <pre><code>
      // отрендорить children или default параметр
      const WelcomeAnn = () =&gt; {
        return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
      };
      
      const Welcome = (props) =&gt; {
        return &lt;h2&gt;{props.children ? props.children : &quot;default text&quot;}&lt;/h2&gt;;
      };
      // ... 
      &lt;Welcome&gt;
          &lt;WelcomeAnn /&gt; // Hello, Ann!
      &lt;/Welcome&gt;
      &lt;Welcome&gt;
                      // default text
      &lt;/Welcome&gt;
    </code></pre>
      <p>можно переписать с if</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h2&gt;{props.children}&lt;/h2&gt;;
      } else {
        return &lt;h2&gt;default text&lt;/h2&gt;;
      }
    };
    </code></pre>
      <p>Или так</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return props.children || &lt;h3&gt;default text&lt;/h3&gt;;
    };
    // props.children не обернул в h3 т.к он был бы внутри span
    </code></pre>
      <p>Даже сработает такое</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return (
        &lt;h3&gt;
          {props.children &amp;&amp; props.children}
          {!props.children &amp;&amp; &quot;default text&quot;}
        &lt;/h3&gt;
      );
    };
    // важно чтобы было что то возвращенно! иначе ошибка
    </code></pre>
      <h2>Спрятать отренденный компонент</h2>
      <pre><code>
    const WelcomeAnn = ({ hide }) =&gt; {
      if (hide) return null;
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h3&gt;{props.children}&lt;/h3&gt;;
      } else {
        return &lt;h3&gt;default text&lt;/h3&gt;;
      }
    };
    // .. 
    &lt;Welcome&gt;
      &lt;WelcomeAnn hide /&gt; // не отобразится
    &lt;/Welcome&gt;
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt; // Hello, Ann!
    &lt;/Welcome&gt;
    // если в первом компоненте передать hide={true}, 
    // а во втором hide={false} - ничего не изменится 
    </code></pre>
      <h2>Обработка событий</h2>
      <p>
        Чтобы свойства не очищались после вызова обработчика события исп. метод
        <code>event.persist()</code>
      </p>
      <pre><code>
    const handleClick = (e) =&gt; {
      <code>e.persist();</code>
      console.log(&quot;event&quot;, e); // в консоле свойства не будут null
    };
    
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <h3>Привязка this</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // undefined
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>1. bind</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
        <code>this.handleClick = this.handleClick.bind(this);</code>
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter 
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>2. синтаксис общедоступных полей классов</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (e) =&gt; {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Передача аргументов</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <p>запись функции подобна к</p>
      <pre><code>
    handleClick = function handleClick(data) {
      return function (e) {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
    };
    </code></pre>
      <p>ещё вариант передачи аргументов</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={(e) =&gt; this.handleClick(&quot;some text&quot;, e)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <p>И ещё</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick.bind(this, &quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    // замечу ,что с bind аргумент event явно не передавал
    </code></pre>
      <h2>Работа со списками</h2>
      <pre><code>
    const arr = [1, 2, 3, 4, 5, 6];
    const elements = arr.map((item) =&gt; &lt;li&gt;{item}&lt;/li&gt;);

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;ul&gt;<code>{elements}</code>&lt;/ul&gt; // elements в {}!
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }

    export default App;
    </code></pre>
      <p>В компонентах:</p>
      <pre><code>
      // List
    export const List = ({items}) =&gt; {
    const elements = items.map(item =&gt; &lt;li key={item.toString()}&gt;{item}&lt;/li&gt;)
        return &lt;ul&gt;{elements}&lt;/ul&gt;
    }
    // App 
    import { List } from &quot;./components/List&quot;;

    const arr = [1, 2, 3, 4, 5];

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;List items={arr} /&gt;
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }
    </code></pre>
      <h2>Изменение состояния</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        <code>
          this.setState({
            count: this.state.count + 1
          })
        </code>
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Сосотояние и жизненный цикл</h2>
      <h3>Асинхронное обновление</h3>
      <p>
        При наличии нескольких вызовов setState() React может объединять их в
        один общий пакет обновлений для увеличения производительности.
      </p>

      <p>
        Так как объекты this.props и this.state могут обновляться асинхронно, не
        стоит полагаться на значения этих объектов для вычисления состояния.
        Например:
      </p>
      <pre><code>
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
      </code></pre>
      <p>
        Для обновления надо использовать другую версию функции setState(),
        которая в качестве параметра принимает функцию. Данная функция имеет два
        параметра: предыдущее состояние объекта state и объект props на момент
        применения обновления:
      </p>
      <pre><code>
        this.setState(function(prevState, props) {
          return {
            counter: prevState.counter + props.increment
          };
        });
      </code></pre>

      <!-- container  -->
    </div>
    <script src="./src/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
