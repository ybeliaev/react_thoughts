<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/style.css" />
    <link rel="stylesheet" href="./src/highlight/styles/darcula.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&family=Roboto+Mono&family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <title>React thoughts</title>
  </head>

  <body>
    <div class="container">
      <h2>Варианты дефолтных значений</h2>
      <pre><code>
    function MyFunc({ text = &quot;some text&quot; }) {
      return &lt;div&gt;{text}&lt;/div&gt;;
    }
    const MySecondFunc = (props) =&gt; {
      return &lt;div&gt;{props.name || &quot;User&quot;}&lt;/div&gt;;
    };
    class MyClassComponent extends React.Component {
      render() {
        return &lt;div&gt;{this.props.name || &quot;User from class&quot;}&lt;/div&gt;;
      }
    }
    &lt;MyFunc text=&quot;1&quot; /&gt; // 1
    &lt;MyFunc /&gt; // some text
    &lt;MyFunc text=&quot;3&quot; /&gt; // 3
    &lt;MySecondFunc name=&quot;Yura&quot; /&gt; // Yura
    &lt;MySecondFunc /&gt; // User
    &lt;MyClassComponent name=&quot;John&quot; /&gt; // John
    &lt;MyClassComponent /&gt; // User from class
    </code></pre>
      <h2>Функция и класс</h2>
      <pre><code>
    const Welcome = ({ name }) =&gt; {
      return &lt;h2&gt;Hi, {name}!&lt;/h2&gt;;
    };
    class WelcomeClass extends React.Component {
      render() {
        return &lt;h2&gt;Hi, {this.props.name}!&lt;/h2&gt;;
      }
    }
    </code></pre>
      <h2>Дочерние компоненты</h2>
      <pre><code>
    const WelcomeAnn = () =&gt; {
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      return props.children;
    };
    //... 
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt;
    &lt;/Welcome&gt;
    </code></pre>
      <p>Для случая с разметкой было бы с фигурными скобками</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return &lt;h2&gt;{props.children}&lt;/h2&gt;;
    };
    </code></pre>
      <h2>Условные операторы</h2>
      <pre><code>
      // отрендорить children или default параметр
      const WelcomeAnn = () =&gt; {
        return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
      };
      
      const Welcome = (props) =&gt; {
        return &lt;h2&gt;{props.children ? props.children : &quot;default text&quot;}&lt;/h2&gt;;
      };
      // ... 
      &lt;Welcome&gt;
          &lt;WelcomeAnn /&gt; // Hello, Ann!
      &lt;/Welcome&gt;
      &lt;Welcome&gt;
                      // default text
      &lt;/Welcome&gt;
    </code></pre>
      <p>можно переписать с if</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h2&gt;{props.children}&lt;/h2&gt;;
      } else {
        return &lt;h2&gt;default text&lt;/h2&gt;;
      }
    };
    </code></pre>
      <p>Или так</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return props.children || &lt;h3&gt;default text&lt;/h3&gt;;
    };
    // props.children не обернул в h3 т.к он был бы внутри span
    </code></pre>
      <p>Даже сработает такое</p>
      <pre><code>
    const Welcome = (props) =&gt; {
      return (
        &lt;h3&gt;
          {props.children &amp;&amp; props.children}
          {!props.children &amp;&amp; &quot;default text&quot;}
        &lt;/h3&gt;
      );
    };
    // важно чтобы было что то возвращенно! иначе ошибка
    </code></pre>
      <h2>Спрятать отренденный компонент</h2>
      <pre><code>
    const WelcomeAnn = ({ hide }) =&gt; {
      if (hide) return null;
      return &lt;span&gt;Hello, Ann!&lt;/span&gt;;
    };
    
    const Welcome = (props) =&gt; {
      if (props.children) {
        return &lt;h3&gt;{props.children}&lt;/h3&gt;;
      } else {
        return &lt;h3&gt;default text&lt;/h3&gt;;
      }
    };
    // .. 
    &lt;Welcome&gt;
      &lt;WelcomeAnn hide /&gt; // не отобразится
    &lt;/Welcome&gt;
    &lt;Welcome&gt;
      &lt;WelcomeAnn /&gt; // Hello, Ann!
    &lt;/Welcome&gt;
    // если в первом компоненте передать hide={true}, 
    // а во втором hide={false} - ничего не изменится 
    </code></pre>
      <h2>Обработка событий</h2>
      <p>
        Чтобы свойства не очищались после вызова обработчика события исп. метод
        <code>event.persist()</code>
      </p>
      <pre><code>
    const handleClick = (e) =&gt; {
      <code>e.persist();</code>
      console.log(&quot;event&quot;, e); // в консоле свойства не будут null
    };
    
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <h3>Привязка this</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // undefined
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>1. bind</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
        <code>this.handleClick = this.handleClick.bind(this);</code>
      }
      handleClick(e) {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter 
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h3>2. синтаксис общедоступных полей классов</h3>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (e) =&gt; {
        e.persist();
        console.log(&quot;event&quot;, e);
        console.log(&quot;this&quot;, this); // this == ClickCounter
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Передача аргументов</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;Increment+&lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
      
    </code></pre>
      <p>запись функции подобна к</p>
      <pre><code>
    handleClick = function handleClick(data) {
      return function (e) {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
    };
    </code></pre>
      <p>ещё вариант передачи аргументов</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data);
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={(e) =&gt; this.handleClick(&quot;some text&quot;, e)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <p>И ещё</p>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data, e) =&gt; {
        e.persist();
        console.log(&quot;event: &quot;, e);
        console.log(&quot;data: &quot;, data); // data:  some text
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick.bind(this, &quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    // замечу ,что с bind аргумент event явно не передавал
    </code></pre>
      <h2>Работа со списками</h2>
      <pre><code>
    const arr = [1, 2, 3, 4, 5, 6];
    const elements = arr.map((item) =&gt; &lt;li&gt;{item}&lt;/li&gt;);

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;ul&gt;<code>{elements}</code>&lt;/ul&gt; // elements в {}!
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }

    export default App;
    </code></pre>
      <p>В компонентах:</p>
      <pre><code>
      // List
    export const List = ({items}) =&gt; {
    const elements = items.map(item =&gt; &lt;li key={item.toString()}&gt;{item}&lt;/li&gt;)
        return &lt;ul&gt;{elements}&lt;/ul&gt;
    }
    // App 
    import { List } from &quot;./components/List&quot;;

    const arr = [1, 2, 3, 4, 5];

    function App() {
      return (
        &lt;div className=&quot;App&quot;&gt;
          &lt;header className=&quot;App-header&quot;&gt;
            &lt;List items={arr} /&gt;
            &lt;ClickCounter /&gt;
          &lt;/header&gt;
        &lt;/div&gt;
      );
    }
    </code></pre>
      <h2>Изменение состояния</h2>
      <pre><code>
    export class ClickCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
        };
      }
      handleClick = (data) =&gt; (e) =&gt; {
        <code>
          this.setState({
            count: this.state.count + 1
          })
        </code>
      };
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
            &lt;button onClick={this.handleClick(&quot;some text&quot;)}&gt;
              Increment+
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    </code></pre>
      <h2>Сосотояние и жизненный цикл</h2>
      <h3>Асинхронное обновление</h3>
      <a href="https://habr.com/ru/post/358090/">Понимание жизненного цикла</a>
      <p>
        При наличии нескольких вызовов <code>setState()</code> React может
        объединять их в один общий пакет обновлений для увеличения
        производительности.
      </p>

      <p>
        Так как объекты <code>this.props</code> и <code>this.state</code> могут
        обновляться асинхронно, не стоит полагаться на значения этих объектов
        для вычисления состояния. Например:
      </p>
      <pre><code>
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
      </code></pre>
      <p>
        Для обновления надо использовать другую версию функции<code>
          setState()</code
        >, которая в качестве параметра принимает функцию. Данная функция имеет
        два параметра: предыдущее состояние объекта <code>state</code> и объект
        <code>props</code> на момент применения обновления:
      </p>
      <pre><code>
        this.setState(function(prevState, props) {
          return {
            counter: prevState.counter + props.increment
          };
        });
      </code></pre>
      <h2>Добавление методов жизненного цикла</h2>
      <p>
        первоначальный рендеринг компонента в DOM - mounting( монтирование )
      </p>
      <p>Размонтирование ( unmounting ) - узел удаляется</p>
      <p>
        <code>componentDidMount()</code> запускается после того, как компонен
        отренд. в DOM
      </p>
      <div class="alert">
        <p>
          Эта функция будет вызвана лишь раз во всем жизненном цикле данного
          компонента и будет сигнализировать, что компонент и все его дочерние
          компоненты отрисовались без ошибок.
        </p>
      </div>
      <div class="alert">
        <p>
          Т.к. эта функция гарантирована будет вызвана лишь раз, то это
          превосходный кандидат для выполнения любых сайд-эффектов, как то AJAX
          запросы.
        </p>
        <p>Не вызывайте this.setState т.к. это вызовет перерисовку.</p>
      </div>
      <div class="alert">
        <p>
          Побо́чные эффе́кты (англ. side effects) — любые действия работающей
          программы, изменяющие среду выполнения (англ. execution environment).
        </p>
        <p>
          Побочный эффект функции — возможность в процессе выполнения своих
          вычислений: читать и модифицировать значения глобальных переменных,
          осуществлять операции ввода-вывода, реагировать на исключительные
          ситуации, вызывать их обработчики. Если вызвать функцию с побочным
          эффектом дважды с одним и тем же набором значений входных аргументов,
          может случиться так, что в качестве результата будут возвращены разные
          значения.
        </p>
      </div>

      <p>Пример с часами</p>
      <pre><code>
      // ***** Clock ****
      import React from &quot;react&quot;;

      export class Clock extends React.Component{
          constructor(props) {
              super(props);
              this.state = {date: new Date()}
          }
          componentDidMount() {
              this.timerID = setInterval(() =&gt; this.tick(), 1000)
          }
          componentWillUnmount() {
              clearInterval(this.timerID)
          }
          tick(){
              this.setState({
                  date: new Date()
              })
          }

          render() {
              return(
                  &lt;div&gt;
                      &lt;h2&gt;Hi, clock!&lt;/h2&gt;
                      &lt;h3&gt;now {this.state.date.toLocaleTimeString()}&lt;/h3&gt;
                  &lt;/div&gt;
              )
          }
      }
      // **** App ****
      ... 
      &lt;Clock /&gt;
      ...

      </code></pre>
      <p>Тикает!</p>
      <div class="alert">
        <p>Не копируйте пропсы в состояние:</p>
        <pre><code>
          this.setState({
            value: props.value
        })
        </code></pre>
        <p>Не менять состояние в конструкторе</p>
      </div>
      <p>
        <code>componentDidUpdate(prevProps, prevState)</code>: вызывается сразу
        после обновления компонента (если
        <code>shouldComponentUpdate</code> возвращает true). В качестве
        параметров передаются старые значения объектов <code>props</code> и
        <code>state</code>.
      </p>
      <div class="alert">
        <p>
          Эта функция будет вызываться после того как отработала функция render,
          в каждом цикле перерисовки. Это означает, что вы можете быть уверены,
          что компонент и все его дочерние компоненты уже перерисовали себя.
        </p>
        <p>
          В связи с этим эта функция является единственной функцией, что
          гарантировано будет вызвана только раз в каждом цикле перерисовки,
          поэтому любые сайд-эффекты рекомендуется выполнять именно здесь.
        </p>
      </div>
      <div class="alert">
        <p>Выполняйте сайд-эффекты (Вызовы AJAX и т.д.)</p>
        <p>
          Не вызывайте this.setState т.к. это будет вызывать циклическую
          перерисовку.
        </p>
      </div>
      <pre><code>
      // если userID не изменился - не нужно что то делать
      componentDidUpdate(prevProps, prevState, snapshot) {
        if(this.props.userID !== prevProps.userID)
            // что то делать
      }
      // можно и setState но только с условием if, иначе возможен бесконечный цикл
      </code></pre>
      <div class="alert">
        <p>
          <code>componentWillUnmount()</code>: вызывается перед удалением
          компонента из DOM - отмена таймера, подписок..созданных в
          componentWillMount()
        </p>
      </div>
      <div class="alert">
        <p>
          Используйте эту функцию для «очистки» после компонента, если он
          использует таймеры (<code>setTimeout</code>,
          <code>setInterval</code>), открывает сокеты или производит любые
          операции, которые нуждаются в закрытии или удалении.
        </p>
      </div>
      <div class="alert">
        <p>
          Не вызывайте <code>this.setState</code>, не стартуйте новых слушателей
          или таймеры.
        </p>
      </div>

      <!-- container  -->
    </div>
    <script src="./src/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
